<!DOCTYPE html>
<script src="libs/jquery.min.js"></script>
<script src="libs/jquery.csv.min.js"></script>
<script src="libs/moment.js"></script>
<script src="libs/moment.interval.js"></script>
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-collection.v1.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-format.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-time.v1.min.js"></script>
<script src="https://d3js.org/d3-time-format.v2.min.js"></script>
<script src="https://d3js.org/d3-scale.v2.min.js"></script>
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<style type="text/css">
    span {
        font-family: "Roboto script=all rev=1", sans-serif;
        font-style: normal;
        text-transform: capitalize;
    }

    tr.timeline {

    }

    tr.timeline th.tic {
        border-width: 0px 0px 4px 0px;
        padding: 30px 15px 0px;
        margin-bottom: 30px;
        border-bottom: 8px solid darkcyan;
        font-family: "Roboto script=all rev=1", sans-serif;
        font-style: italic;
        font-weight: 100;
        font-size: 2em;
        color: darkcyan;
        text-shadow: 1px 1px 3px white;
        cursor: pointer;
    }

    .highlight{
        color:darkred !important;
        border-color:darkred !important;
    }
    .downlight{
        color:darkcyan !important;
    }
</style>
<table id="cloud"></table>
<script>
    $.ajax({
        url: "/dataset/citibeats.csv",
        success: function (result) {
            start($.csv.toObjects(result));
        }
    });



    // global values
    var stopwords = ['milton', 'keynes', 'mk'];
    var maxValue = 1;
    var node = '#cloud';



    function start(data) {
        // console.log(data);

        var startDate = null, untilDate = null;


        // elaborate the CSV into the data structure
        var tags = data.reduce(function (res, val) {
            if (stopwords.indexOf(val.tag.toLowerCase()) > -1) {
                return res;
            }
            if (parseFloat(val.tag)) {
                return res;
            }

            var index = res.map(function (value) {
                return value.tag
            }).indexOf(val.tag);
            var date = moment(val.since).toISOString();
            var until = moment(val.until).toISOString();

            if (!startDate || startDate > date) {
                startDate = date;
            }
            if (!untilDate || untilDate < until) {
                untilDate = until;
            }

            if (index < 0) {
                var o = {
                    sum: parseInt(val.value),
                    dates: [],
                    values: [],
                    tag: val.tag
                };
                res.push(o);
                index = res.length - 1;
            }

            res[index].dates.push(date);
            res[index].values.push(parseInt(val.value));
            res[index].sum += parseInt(val.value);

            return res;
        }, []); // higher value to lower


        // console.log(timeWindow.start().toISOString(),timeWindow.end().toISOString());
        var days = generateDates(startDate, untilDate);
        // print time
        printTimeline(days, node);

        // console.log(days);
        // merging dates in intervals
        tags = mergeDatesInIntervals(tags);


        // split tags by interval
        tags = splitTags(tags);

        // sort tags
        // incremental duration, higher value
        tags.sort(function (a, b) {
            // incremental duration
            var delta = a.duration - b.duration;
            if (delta !== 0) return delta;
            // decrementing valye
            return b.value - a.value;
        }); // sort by min duration;
        tags.reduce(function (value) {

        }, []);

        console.log(tags);
        // building the matrix
        var matrix = buildMatrix(tags, days);

        console.log(matrix);
        // building the cloud tags
        var cloud = buildCloud(matrix);

        console.log(cloud);
        // rendering the cloud
        renderTable(cloud);


        initListners(days, matrix);
    }




    function initListners(days, matrix) {
        var daysIndexes = days.map(function (value) { return value.toISOString(); });
        var highlight = '';

        $('.tic').each(function () {
            $(this).click(function(e){

                $('.tic').each(function () {$(this).removeClass('highlight')});

                var date = moment(e.target.attributes.value.value);

                // if clicked > reset
                if(highlight === date.toISOString()){
                    highlight = '';
                    // reset style
                    setStyle();
                    return;
                }
                $(this).addClass('highlight');
                highlight = date.toISOString();

                // get the column index of the clicked date
                var index = daysIndexes.indexOf(highlight);

                // get the relevant tags
                var tags = matrix.reduce(function (tags, layer, i) {
                    if( typeof layer[index] === 'undefined'){return tags;}
                    return tags.concat(layer[index]);
                }, []);

                // highlight tags
                setStyle(tags);

                console.log('click',highlight,index, tags);
            });
        });
    }

    function setStyle(highlights) {
        console.log('highlights',highlights);
        // reset style
        if(typeof highlights === 'undefined' || !highlights || highlights === ''){
            // reset all style
            $('.tag').each(function () {
                // remove highlight class
               $(this).removeClass('highlight');
               $(this).removeClass('downlight');
            });
            return;
        }

        // set style
        $('.tag').each(function () {
            var tag = $(this).text();
            console.log('setting',tag,highlights,highlights.indexOf(tag));
            // if tag included in the highlights list
            if(highlights.indexOf(tag) < 0 ){
                $(this).removeClass('highlight');
                $(this).addClass('downlight');
            }else{
                $(this).addClass('highlight');
                $(this).removeClass('downlight');
            }
        });
    }

    function mergeDatesInIntervals(tags) {
        return tags.map(function (value) {
            value.dates.sort();
            // console.log(value.dates);
            value.intervals = [];
            value.valuesInterval = [];
            value.dates.map(function (key, index) {

                // if not, add an interval
                if (value.intervals.length < 1 || value.intervals[value.intervals.length - 1].end().toISOString() !== key) {
                    value.intervals.push(moment.interval(moment(key), moment.duration(1, 'd')));
                    value.valuesInterval.push(value.values[index]);
                    // console.log(intervals[0].period().asDays());
                    if (maxValue < value.values[index]) {
                        maxValue = value.values[index];
                    }
                } else {
                    // update interval duration
                    value.intervals[value.intervals.length - 1] = moment.interval(value.intervals[value.intervals.length - 1].start(), value.intervals[value.intervals.length - 1].period().add(1, 'd'))
                    value.valuesInterval[value.intervals.length - 1] += value.values[index];
                    if (maxValue < value.valuesInterval[value.intervals.length - 1]) {
                        maxValue = value.valuesInterval[value.intervals.length - 1];
                    }
                }

            });
            value.durations = value.intervals.map(function (value2) {
                return value2.period().asDays()
            });
            return value;
        });
    }


    function splitTags(tags) {
        return tags.reduce(function (r, tag) {

            return r.concat(...tag.intervals.map(function (i, index) {
                var o = {
                    key: i.start().toISOString() + " " + i.end().toISOString(),
                    tag: tag.tag,
                    value: tag.valuesInterval[index],
                    interval: i,
                    start: i.start().toISOString(),
                    until: i.end().toISOString(),
                    duration: i.period().asDays(),
                    dates: generateDates(i.start().toISOString(), i.end().toISOString())
                };

                return o;
            }));
            }, []);
    }

    function printTimeline(days, node) {
        var daysLabes = '<tr class="timeline">' + days.reduce(function (children, d) {
            return children + '<th class="tic" value="'+d.toISOString()+'">' + d.format('DD/MM/YY') + '</th>';
        }, '') + '</tr>';
        $(node).append(daysLabes);
    }

    function buildMatrix(tags, days) {
        // building the matrix
        var matrix = [Array(days.length)];
        var isoDays = days.map(function (value) {
            return value.toISOString()
        });
        tags.map(function (o) {

            // building the matrix
            // testing if there is room in the current layer

            // scan all matrix level to fit the dates
            var currentIndex = matrix.reduce(function (i, layer, cIndex) {
                // if found a suitable layer do nothing
                if (i !== false) {
                    return i;
                }

                // scan the layer to fit the dates
                var c = o.dates.reduce(function (c, v) {
                    // console.log(matrix[matrix.length - 1],v.toISOString());
                    // if(matrix.length < 1) return true;
                    return c && (!layer[isoDays.indexOf(v.toISOString())] || layer[isoDays.indexOf(v.toISOString())] === o.tag + ":" + o.value)
                }, true);
                // found a layer, returning index
                if (c !== false) {
                    return cIndex;
                }
                // return false to continue
                return false;
            }, false);


            // console.log('can be updated?',currentIndex,matrix[matrix.length - 1],o.tag);
            // add a layer
            // if there is no place, add a new layer
            if (currentIndex === false) {
                matrix.push(Array(days.length));
                // update layer
                currentIndex = matrix.length - 1;
            }
            // set the dates in the right layer
            o.dates.map(function (v) {
                // update latest layer
                // console.log(matrix,matrix.length-1);
                return matrix[currentIndex][isoDays.indexOf(v.toISOString())] = o.tag + ":" + o.value
                // return matrix[currentIndex][isoDays.indexOf(v.toISOString())] = o.tag
            }, true);


            return o;
        });
        return matrix;
    }

    function buildCloud(matrix) {
        // console.log(matrix);
        var cloud = matrix.map(function (layer) {
            // console.log(layer);
            var newLayer = [];
            for (var i = 0; i < layer.length; i++) {
                var value = layer[i];
                var key = typeof value === 'undefined' ? '' : value;
                // console.log(key,value);
                // if first element or new
                if (newLayer.length < 1 || (newLayer[newLayer.length - 1].key !== key)) {
                    newLayer.push({key: key, length: 1});
                } else {
                    // else increment
                    newLayer[newLayer.length - 1].length++;
                }
            }
            ;

            // console.log(newLayer);
            return newLayer;
        });
        return cloud;
    }

    function renderTable(cloud) {
        var table = cloud.reduce(function (table, layer, i) {
            var row = layer.reduce(function (row, item) {
                // get label and value > key => label:value
                var key = item.key.split(":");
                var label = key[0];
                var value = key[1];
                var distance = item.length;
                // font size => value
                // font weight => 1/distance
                // calc font size and weight
                var fontSize = size(value),
                    fontWeight = weigth(distance);
                // console.log(fontSize);
                var cell = '<span style="font-size:' + fontSize + 'px;font-weight:' + fontWeight + '; ">' + item.key + '</span>';
                return row.concat('<th class="tag" colspan="', item.length, '">', cell, '</th>');
            }, '')

            if (i % 2 === 0) {
                $('#cloud').prepend('<tr>', row, '</tr>');
            } else {
                $('#cloud').append('<tr>', row, '</tr>');
            }
            table = table.concat('<tr>', row, '</tr>');
            return table
        }, '')
        // $('#cloud').append(table);
    }

    function size(value) {
        var minSize = 8,
            maxSize = 40;
        // console.log(maxValue);
        // var size = d3.scaleLinear()
        var d = d3.scaleLog()
        // var size = d3.scalePow()
            .domain([1, maxValue])
            // .domain([1,maxValue])
            .range([minSize, maxSize]);
        return d(value);
    }

    function weigth(size) {
        var d = d3.scaleLog()
            .base(2)
            .domain([1, 20])
            .range([900, 100]);
        // var t = d3.scaleQuantize()
        //     .domain([1,31])
        //     .range([900,800,700,600,500,400,300,200,100]);
        // console.log(size,d(size));
        return d(size);
    };

    function generateDates(start, end) {
        var days = [];
        for (var m = moment(start); m.isBefore(end); m.add('days', 1)) {
            // console.log(m.toISOString());
            days.push(moment(m.toISOString()));
        }
        return days;
    }

</script>